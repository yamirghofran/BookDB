// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: books.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBook = `-- name: CreateBook :one
INSERT INTO Books (
    goodreads_id, goodreads_url, title, description, publication_year,
    cover_image_url, average_rating, ratings_count
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, ncf_id, goodreads_id, goodreads_url, title, description, publication_year, cover_image_url, average_rating, ratings_count, search_vector, created_at, updated_at
`

type CreateBookParams struct {
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, createBook,
		arg.GoodreadsID,
		arg.GoodreadsUrl,
		arg.Title,
		arg.Description,
		arg.PublicationYear,
		arg.CoverImageUrl,
		arg.AverageRating,
		arg.RatingsCount,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.NcfID,
		&i.GoodreadsID,
		&i.GoodreadsUrl,
		&i.Title,
		&i.Description,
		&i.PublicationYear,
		&i.CoverImageUrl,
		&i.AverageRating,
		&i.RatingsCount,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE FROM Books
WHERE id = $1
`

func (q *Queries) DeleteBook(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBook, id)
	return err
}

const getBookByGoodreadsID = `-- name: GetBookByGoodreadsID :one
SELECT id, goodreads_id, goodreads_url, title, description, publication_year, cover_image_url, average_rating, ratings_count, search_vector::text AS search_vector, created_at, updated_at
FROM Books
WHERE goodreads_id = $1 LIMIT 1
`

type GetBookByGoodreadsIDRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetBookByGoodreadsID(ctx context.Context, goodreadsID int64) (GetBookByGoodreadsIDRow, error) {
	row := q.db.QueryRow(ctx, getBookByGoodreadsID, goodreadsID)
	var i GetBookByGoodreadsIDRow
	err := row.Scan(
		&i.ID,
		&i.GoodreadsID,
		&i.GoodreadsUrl,
		&i.Title,
		&i.Description,
		&i.PublicationYear,
		&i.CoverImageUrl,
		&i.AverageRating,
		&i.RatingsCount,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookByID = `-- name: GetBookByID :one

SELECT
    b.id, b.goodreads_id, b.goodreads_url, b.title, b.description, b.publication_year,
    b.cover_image_url, b.average_rating, b.ratings_count,
    b.search_vector::text AS search_vector, b.created_at, b.updated_at,
    COALESCE(ARRAY_AGG(DISTINCT a.name ORDER BY a.name) FILTER (WHERE a.name IS NOT NULL), '{}') AS authors,
    COALESCE(ARRAY_AGG(DISTINCT g.name ORDER BY g.name) FILTER (WHERE g.name IS NOT NULL), '{}') AS genres
FROM Books b
LEFT JOIN BookAuthors ba ON b.id = ba.book_id
LEFT JOIN Authors a ON ba.author_id = a.id
LEFT JOIN BookGenres bg ON b.id = bg.book_id
LEFT JOIN Genres g ON bg.genre_id = g.id
WHERE b.id = $1
GROUP BY b.id -- Assuming b.id is PK
LIMIT 1
`

type GetBookByIDRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	Authors         interface{}
	Genres          interface{}
}

// Return all columns after creation
func (q *Queries) GetBookByID(ctx context.Context, id pgtype.UUID) (GetBookByIDRow, error) {
	row := q.db.QueryRow(ctx, getBookByID, id)
	var i GetBookByIDRow
	err := row.Scan(
		&i.ID,
		&i.GoodreadsID,
		&i.GoodreadsUrl,
		&i.Title,
		&i.Description,
		&i.PublicationYear,
		&i.CoverImageUrl,
		&i.AverageRating,
		&i.RatingsCount,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Authors,
		&i.Genres,
	)
	return i, err
}

const getBooksByAuthor = `-- name: GetBooksByAuthor :many
SELECT b.id, b.goodreads_id, b.goodreads_url, b.title, b.description, b.publication_year, b.cover_image_url, b.average_rating, b.ratings_count, b.search_vector::text AS search_vector, b.created_at, b.updated_at
FROM Books b
JOIN BookAuthors ba ON b.id = ba.book_id
WHERE ba.author_id = $1
ORDER BY b.title
`

type GetBooksByAuthorRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetBooksByAuthor(ctx context.Context, authorID pgtype.UUID) ([]GetBooksByAuthorRow, error) {
	rows, err := q.db.Query(ctx, getBooksByAuthor, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBooksByAuthorRow
	for rows.Next() {
		var i GetBooksByAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.GoodreadsID,
			&i.GoodreadsUrl,
			&i.Title,
			&i.Description,
			&i.PublicationYear,
			&i.CoverImageUrl,
			&i.AverageRating,
			&i.RatingsCount,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBooksByGenre = `-- name: GetBooksByGenre :many
SELECT b.id, b.goodreads_id, b.goodreads_url, b.title, b.description, b.publication_year, b.cover_image_url, b.average_rating, b.ratings_count, b.search_vector::text AS search_vector, b.created_at, b.updated_at
FROM Books b
JOIN BookGenres bg ON b.id = bg.book_id
WHERE bg.genre_id = $1
ORDER BY b.title
`

type GetBooksByGenreRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetBooksByGenre(ctx context.Context, genreID int32) ([]GetBooksByGenreRow, error) {
	rows, err := q.db.Query(ctx, getBooksByGenre, genreID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBooksByGenreRow
	for rows.Next() {
		var i GetBooksByGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.GoodreadsID,
			&i.GoodreadsUrl,
			&i.Title,
			&i.Description,
			&i.PublicationYear,
			&i.CoverImageUrl,
			&i.AverageRating,
			&i.RatingsCount,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooks = `-- name: ListBooks :many
WITH RankedBooks AS (
    SELECT
        b.id,
        b.goodreads_id,
        b.goodreads_url,
        b.title,
        b.description,
        b.publication_year,
        b.cover_image_url,
        b.average_rating,
        b.ratings_count,
        b.search_vector::text AS search_vector,
        b.created_at,
        b.updated_at,
        ROW_NUMBER() OVER(PARTITION BY b.title ORDER BY b.average_rating DESC NULLS LAST, b.ratings_count DESC NULLS LAST, b.id DESC) as rn
    FROM Books b
),
UniqueRankedBooks AS (
    SELECT id, goodreads_id, goodreads_url, title, description, publication_year, cover_image_url, average_rating, ratings_count, search_vector, created_at, updated_at, rn FROM RankedBooks WHERE rn = 1
)
SELECT
    urb.id,
    urb.goodreads_id,
    urb.goodreads_url,
    urb.title,
    urb.description,
    urb.publication_year,
    urb.cover_image_url,
    urb.average_rating,
    urb.ratings_count,
    urb.search_vector,
    urb.created_at,
    urb.updated_at,
    COALESCE(ARRAY_AGG(DISTINCT aut.name ORDER BY aut.name) FILTER (WHERE aut.name IS NOT NULL), '{}') AS authors
FROM UniqueRankedBooks urb
LEFT JOIN BookAuthors ba ON urb.id = ba.book_id
LEFT JOIN Authors aut ON ba.author_id = aut.id
GROUP BY
    urb.id, urb.goodreads_id, urb.goodreads_url, urb.title, urb.description, urb.publication_year,
    urb.cover_image_url, urb.average_rating, urb.ratings_count, urb.search_vector,
    urb.created_at, urb.updated_at -- Ensure all selected non-aggregated columns from urb are in GROUP BY
ORDER BY urb.average_rating DESC NULLS LAST, urb.ratings_count DESC NULLS LAST, urb.title
LIMIT $1 OFFSET $2
`

type ListBooksParams struct {
	Limit  int32
	Offset int32
}

type ListBooksRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	Authors         interface{}
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]ListBooksRow, error) {
	rows, err := q.db.Query(ctx, listBooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksRow
	for rows.Next() {
		var i ListBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.GoodreadsID,
			&i.GoodreadsUrl,
			&i.Title,
			&i.Description,
			&i.PublicationYear,
			&i.CoverImageUrl,
			&i.AverageRating,
			&i.RatingsCount,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Authors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBooks = `-- name: SearchBooks :many
SELECT
    b.id, b.goodreads_id, b.goodreads_url, b.title, b.description, b.publication_year,
    b.cover_image_url, b.average_rating, b.ratings_count,
    b.search_vector::text AS search_vector, b.created_at, b.updated_at,
    COALESCE(ARRAY_AGG(DISTINCT a.name ORDER BY a.name) FILTER (WHERE a.name IS NOT NULL), '{}') AS authors
FROM Books b
LEFT JOIN BookAuthors ba ON b.id = ba.book_id
LEFT JOIN Authors a ON ba.author_id = a.id
WHERE b.search_vector @@ websearch_to_tsquery('english', $1)
GROUP BY b.id -- Assuming b.id is PK
ORDER BY ts_rank(b.search_vector, websearch_to_tsquery('english', $1)) DESC
LIMIT $2 OFFSET $3
`

type SearchBooksParams struct {
	WebsearchToTsquery string
	Limit              int32
	Offset             int32
}

type SearchBooksRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	Authors         interface{}
}

func (q *Queries) SearchBooks(ctx context.Context, arg SearchBooksParams) ([]SearchBooksRow, error) {
	rows, err := q.db.Query(ctx, searchBooks, arg.WebsearchToTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBooksRow
	for rows.Next() {
		var i SearchBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.GoodreadsID,
			&i.GoodreadsUrl,
			&i.Title,
			&i.Description,
			&i.PublicationYear,
			&i.CoverImageUrl,
			&i.AverageRating,
			&i.RatingsCount,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Authors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBook = `-- name: UpdateBook :one
UPDATE Books
SET
  goodreads_id = COALESCE($1, goodreads_id),
  goodreads_url = COALESCE($2, goodreads_url),
  title = COALESCE($3, title),
  description = COALESCE($4, description),
  publication_year = COALESCE($5, publication_year),
  cover_image_url = COALESCE($6, cover_image_url),
  average_rating = COALESCE($7, average_rating),
  ratings_count = COALESCE($8, ratings_count),
  updated_at = CURRENT_TIMESTAMP -- Trigger handles search_vector update
WHERE id = $9
RETURNING id, ncf_id, goodreads_id, goodreads_url, title, description, publication_year, cover_image_url, average_rating, ratings_count, search_vector, created_at, updated_at
`

type UpdateBookParams struct {
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	ID              pgtype.UUID
}

func (q *Queries) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, updateBook,
		arg.GoodreadsID,
		arg.GoodreadsUrl,
		arg.Title,
		arg.Description,
		arg.PublicationYear,
		arg.CoverImageUrl,
		arg.AverageRating,
		arg.RatingsCount,
		arg.ID,
	)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.NcfID,
		&i.GoodreadsID,
		&i.GoodreadsUrl,
		&i.Title,
		&i.Description,
		&i.PublicationYear,
		&i.CoverImageUrl,
		&i.AverageRating,
		&i.RatingsCount,
		&i.SearchVector,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
