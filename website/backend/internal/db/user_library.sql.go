// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_library.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBookToLibrary = `-- name: AddBookToLibrary :exec
INSERT INTO UserLibrary (user_id, book_id)
VALUES ($1, $2)
`

type AddBookToLibraryParams struct {
	UserID pgtype.UUID
	BookID pgtype.UUID
}

func (q *Queries) AddBookToLibrary(ctx context.Context, arg AddBookToLibraryParams) error {
	_, err := q.db.Exec(ctx, addBookToLibrary, arg.UserID, arg.BookID)
	return err
}

const getUserLibrary = `-- name: GetUserLibrary :many
SELECT b.id, b.goodreads_id, b.goodreads_url, b.title, b.description, b.publication_year, b.cover_image_url, b.average_rating, b.ratings_count, b.search_vector::text AS search_vector, b.created_at, b.updated_at -- Select book details
FROM Books b
JOIN UserLibrary ul ON b.id = ul.book_id
WHERE ul.user_id = $1
ORDER BY ul.added_at DESC
`

type GetUserLibraryRow struct {
	ID              pgtype.UUID
	GoodreadsID     int64
	GoodreadsUrl    pgtype.Text
	Title           string
	Description     pgtype.Text
	PublicationYear pgtype.Int8
	CoverImageUrl   pgtype.Text
	AverageRating   pgtype.Numeric
	RatingsCount    pgtype.Int8
	SearchVector    string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetUserLibrary(ctx context.Context, userID pgtype.UUID) ([]GetUserLibraryRow, error) {
	rows, err := q.db.Query(ctx, getUserLibrary, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserLibraryRow
	for rows.Next() {
		var i GetUserLibraryRow
		if err := rows.Scan(
			&i.ID,
			&i.GoodreadsID,
			&i.GoodreadsUrl,
			&i.Title,
			&i.Description,
			&i.PublicationYear,
			&i.CoverImageUrl,
			&i.AverageRating,
			&i.RatingsCount,
			&i.SearchVector,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isBookInLibrary = `-- name: IsBookInLibrary :one
SELECT EXISTS (
    SELECT 1
    FROM UserLibrary
    WHERE user_id = $1 AND book_id = $2
)
`

type IsBookInLibraryParams struct {
	UserID pgtype.UUID
	BookID pgtype.UUID
}

func (q *Queries) IsBookInLibrary(ctx context.Context, arg IsBookInLibraryParams) (bool, error) {
	row := q.db.QueryRow(ctx, isBookInLibrary, arg.UserID, arg.BookID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeBookFromLibrary = `-- name: RemoveBookFromLibrary :exec
DELETE FROM UserLibrary
WHERE user_id = $1 AND book_id = $2
`

type RemoveBookFromLibraryParams struct {
	UserID pgtype.UUID
	BookID pgtype.UUID
}

func (q *Queries) RemoveBookFromLibrary(ctx context.Context, arg RemoveBookFromLibraryParams) error {
	_, err := q.db.Exec(ctx, removeBookFromLibrary, arg.UserID, arg.BookID)
	return err
}
